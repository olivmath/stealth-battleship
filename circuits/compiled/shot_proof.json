{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"14219777619347107934","abi":{"parameters":[{"name":"ships","type":{"kind":"array","length":5,"type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8},{"kind":"boolean"}]}},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"board_hash","type":{"kind":"field"},"visibility":"public"},{"name":"row","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"col","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"is_hit","type":{"kind":"boolean"},"visibility":"public"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10575757171593033517":{"error_kind":"string","string":"resultado desonesto"},"17563642741948022846":{"error_kind":"string","string":"board hash invalido"}}},"bytecode":"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","debug_symbols":"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","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\n\nfn compute_board_hash(\n    ships: [(u8, u8, u8, bool); 5],\n    nonce: Field,\n) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..5 {\n        let (r, c, s, h) = ships[i];\n        inputs[i * 4 + 0] = r as Field;\n        inputs[i * 4 + 1] = c as Field;\n        inputs[i * 4 + 2] = s as Field;\n        inputs[i * 4 + 3] = if h { 1 } else { 0 };\n    }\n    inputs[20] = nonce;\n    Poseidon2::hash(inputs, 21)\n}\n\nfn cell_is_hit(ships: [(u8, u8, u8, bool); 5], row: u8, col: u8) -> bool {\n    let mut hit = false;\n    for i in 0..5 {\n        let (r, c, s, h) = ships[i];\n        for j in 0..5 {\n            if j < s {\n                let (ship_r, ship_c) = if h { (r, c + j) } else { (r + j, c) };\n                if (ship_r == row) & (ship_c == col) {\n                    hit = true;\n                }\n            }\n        }\n    }\n    hit\n}\n\nfn main(\n    // Private inputs\n    ships: [(u8, u8, u8, bool); 5],\n    nonce: Field,\n    // Public inputs\n    board_hash: pub Field,\n    row: pub u8,\n    col: pub u8,\n    is_hit: pub bool,\n) {\n    let computed_hash = compute_board_hash(ships, nonce);\n    assert(computed_hash == board_hash, \"board hash invalido\");\n\n    let actual_hit = cell_is_hit(ships, row, col);\n    assert(actual_hit == is_hit, \"resultado desonesto\");\n}\n\n// ---- TESTES ----\n\nfn test_ships() -> [(u8, u8, u8, bool); 5] {\n    [\n        (0, 0, 5, true),\n        (2, 0, 4, true),\n        (4, 0, 3, true),\n        (6, 0, 3, true),\n        (8, 0, 2, true),\n    ]\n}\n\n#[test]\nfn test_hit() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 0, 0, true);\n}\n\n#[test]\nfn test_miss() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 1, 0, false);\n}\n\n#[test(should_fail)]\nfn test_lying_miss_when_hit() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 0, 0, false);\n}\n\n#[test(should_fail)]\nfn test_lying_hit_when_miss() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 1, 0, true);\n}\n\n#[test(should_fail)]\nfn test_wrong_board_hash() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let wrong_hash: Field = 0;\n    main(ships, nonce, wrong_hash, 0, 0, true);\n}\n","path":"/Users/olivmath/Documents/dev/battleship-zk/circuits/shot_proof/src/main.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\nglobal RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1];\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4);\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/olivmath/nargo/github.com/noir-lang/poseidon/v0.2.6/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}