{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":9020394051611425588,"abi":{"parameters":[{"name":"ships","type":{"kind":"array","length":5,"type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":8},{"kind":"boolean"}]}},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"board_hash","type":{"kind":"field"},"visibility":"public"},{"name":"row","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"col","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"is_hit","type":{"kind":"boolean"},"visibility":"public"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10575757171593033517":{"error_kind":"string","string":"resultado desonesto"},"17563642741948022846":{"error_kind":"string","string":"board hash invalido"}}},"bytecode":"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","debug_symbols":"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","file_map":{"62":{"source":"use poseidon::poseidon2::Poseidon2;\n\nfn compute_board_hash(\n    ships: [(u8, u8, u8, bool); 5],\n    nonce: Field,\n) -> Field {\n    let mut inputs: [Field; 21] = [0; 21];\n    for i in 0..5 {\n        let (r, c, s, h) = ships[i];\n        inputs[i * 4 + 0] = r as Field;\n        inputs[i * 4 + 1] = c as Field;\n        inputs[i * 4 + 2] = s as Field;\n        inputs[i * 4 + 3] = if h { 1 } else { 0 };\n    }\n    inputs[20] = nonce;\n    Poseidon2::hash(inputs, 21)\n}\n\nfn cell_is_hit(ships: [(u8, u8, u8, bool); 5], row: u8, col: u8) -> bool {\n    let mut hit = false;\n    for i in 0..5 {\n        let (r, c, s, h) = ships[i];\n        for j in 0..5 {\n            if j < s {\n                let (ship_r, ship_c) = if h { (r, c + j) } else { (r + j, c) };\n                if (ship_r == row) & (ship_c == col) {\n                    hit = true;\n                }\n            }\n        }\n    }\n    hit\n}\n\nfn main(\n    // Private inputs\n    ships: [(u8, u8, u8, bool); 5],\n    nonce: Field,\n    // Public inputs\n    board_hash: pub Field,\n    row: pub u8,\n    col: pub u8,\n    is_hit: pub bool,\n) {\n    let computed_hash = compute_board_hash(ships, nonce);\n    assert(computed_hash == board_hash, \"board hash invalido\");\n\n    let actual_hit = cell_is_hit(ships, row, col);\n    assert(actual_hit == is_hit, \"resultado desonesto\");\n}\n\n// ---- TESTES ----\n\nfn test_ships() -> [(u8, u8, u8, bool); 5] {\n    [\n        (0, 0, 5, true),\n        (2, 0, 4, true),\n        (4, 0, 3, true),\n        (6, 0, 3, true),\n        (8, 0, 2, true),\n    ]\n}\n\n#[test]\nfn test_hit() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 0, 0, true);\n}\n\n#[test]\nfn test_miss() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 1, 0, false);\n}\n\n#[test(should_fail)]\nfn test_lying_miss_when_hit() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 0, 0, false);\n}\n\n#[test(should_fail)]\nfn test_lying_hit_when_miss() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let board_hash = compute_board_hash(ships, nonce);\n    main(ships, nonce, board_hash, 1, 0, true);\n}\n\n#[test(should_fail)]\nfn test_wrong_board_hash() {\n    let ships = test_ships();\n    let nonce: Field = 42;\n    let wrong_hash: Field = 0;\n    main(ships, nonce, wrong_hash, 0, 0, true);\n}\n","path":"/Users/olivmath/Documents/dev/battleship-zk/circuits/shot_proof/src/main.nr"},"70":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\nglobal RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1];\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4);\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/olivmath/nargo/github.com/noir-lang/poseidon/v0.2.6/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}